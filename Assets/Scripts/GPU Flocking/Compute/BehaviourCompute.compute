// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define GROUP_SIZE 64
#define BOID_VISION_CONE_MIN_DOT -0.5f

#include "../cgincs/bccNoise4.cginc"
#include "../cgincs/boidSteering.cginc"

/* Boids */
struct Boid
{
    float3 position, velocity;
};

//boid constructor
Boid ConstructBoid(float3 position, float3 velocity)
{
    Boid boid;
    boid.position = position;
    boid.velocity = velocity;
    return boid;
}

/* Flock buffer */
RWStructuredBuffer<Boid> boids;
uint numBoids;

/* Flock behaviour params, same for each boid */
//boid movement
float moveSpeed;
float mass;
float friction;
float deltaTime; //to scale boid movement by time since last update

//other boid reactions
float neighbourDist;
float avoidDist;
float avoidSpeed;

//cursor following
bool usingCursorFollow;
float cursorFollowSpeed;
float arrivalSlowStartDist;
float3 cursorPos;

//movement bounds
bool usingBounds;
float boundsSize;
float3 boundsCentre;
float boundsReturnSpeed;

//idle movement
bool usingIdleMvmt;
Texture2D idleNoiseTex;
float idleNoiseFrequency;
float idleOffset;
float idleMoveSpeed;

/* Boid positions/forward directions/up directions buffers, for passing to Graphics.DrawMeshInstancedIndirect */
RWStructuredBuffer<float4> boidPositions;
//RWStructuredBuffer<float4> boidForwardDirs;
//RWStructuredBuffer<float4> boidUpDirs;

float3 ReactToOtherBoids(uint id)
{
    Boid boid = boids[id];
    float3 pos = boid.position;
    float3 vel = boid.velocity;

    float3 avoidDir = float3(0, 0, 0);
    float3 centre = float3(0, 0, 0);
    float3 velocityMatch = float3(0, 0, 0);

    uint neighbourCount = 0;
    for (uint i = 0; i < numBoids; i++)
    {
        if (i != id)
        {
            Boid otherBoid = boids[i];
            float3 otherBoidPos = otherBoid.position;
            float3 otherBoidVel = otherBoid.velocity;
            float dist = distance(pos, otherBoidPos);

            //https://github.com/Shinao/Unity-GPU-Boids/blob/master/Assets/2-GPU_Boids_Compute/Boid_Simple.compute - look at

            //if (dist < neighbourDist && length(vel) > 0 && length(otherBoidVel) > 0 && dot(normalize(vel), normalize(otherBoidVel)) > BOID_VISION_CONE_MIN_DOT) //this won't work if a velocity is zero
            if (dist < neighbourDist)
            {
                neighbourCount++;
                
                /*
                if (dist < avoidDist)
                {
                    avoidDir += (pos - otherBoidPos) * saturate(1.0f - (dist / avoidDist)); //scale avoid speed by distance
                }
                else
                {
                    centre += otherBoidPos - pos;
                    velocityMatch += otherBoidVel;
                }
                */

                //if (dist < avoidDist) avoidDir += (pos - otherBoidPos) * saturate(1.0f - (dist / avoidDist)); //scale avoid speed by distance (max ||boid pos - other boid pos||)
                avoidDir += (pos - otherBoidPos) * saturate(1.0f - (dist / avoidDist)) * (dist < avoidDist); //scale avoid speed by distance (max ||boid pos - other boid pos||)
                centre += otherBoidPos - pos;
                velocityMatch += otherBoidVel;
            }
        }
    }

    float avg = 1 / (float)(neighbourCount + 1); //if neighbourCount == 0, add 1 to avoid a divide-by-zero
    centre *= avg;
    velocityMatch *= avg;

    /*
    if (length(avoidDir) > 0)
    {
        return (normalize(avoidDir) * avoidSpeed) + centre + velocityMatch;
    }
    else
    {
        return centre + velocityMatch;
    }
    */

    return (avoidDir * avoidSpeed) + centre + velocityMatch;
}


float3 MoveIdle(uint id)
{
    return Bcc4NoiseBaseDirectional3D((boids[id].position + idleOffset) * idleNoiseFrequency) * idleMoveSpeed * (int)usingIdleMvmt;
}

float3 FollowCursor(uint id)
{
    return arrival(boids[id].position, boids[id].velocity, cursorPos, cursorFollowSpeed, arrivalSlowStartDist) * (int)usingCursorFollow;
    //return seek(boids[id].position, boids[id].velocity, cursorPos, cursorFollowSpeed);
}

float3 ReturnToBounds(uint id)
{
    float3 position = boids[id].position;
    return normalize(boundsCentre - position) * boundsReturnSpeed * (int)(distance(boundsCentre, position) > boundsSize) * usingBounds;
}

//returns boid buffer with new positions and velocities
[numthreads(GROUP_SIZE, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint idX = id.x;
    
    float drag = 1 - friction;
    float3 newVel = (boids[idX].velocity * drag) + ((ReactToOtherBoids(idX) + FollowCursor(idX) + MoveIdle(idX) + ReturnToBounds(idX)) * deltaTime);
    //if (length(newVel) > (moveSpeed * deltaTime)) newVel = normalize(newVel) * moveSpeed * deltaTime;
    float3 newPos = boids[idX].position + newVel;
    
    boids[idX] = ConstructBoid(newPos, newVel);
    boidPositions[idX] = float4(newPos, 1);
}