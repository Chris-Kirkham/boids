//#include "Assets/Shaders/cginc/Perlin.cginc"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define GROUP_SIZE 1024
#define BOID_VISION_CONE_MIN_DOT -0.5f

/* Boids */
struct Boid
{
    float3 position, velocity;
};

Boid ConstructBoid(float3 position, float3 velocity)
{
    Boid boid;
    boid.position = position;
    boid.velocity = velocity;

    return boid;
}

RWStructuredBuffer<Boid> boids;
uint numBoids;

/* Flock behaviour params, same for each boid */
//other boid reactions
float viewDist;
float avoidDist;
float avoidSpeed;

//cursor following
bool usingCursorFollow;
float cursorFollowSpeed;
float3 cursorPos;

//movement bounds
bool usingBounds;
float boundsSize;
float3 boundsCentre;
float boundsReturnSpeed;

//idle move
bool usingIdleMvmt;
float idleNoiseFrequency;
float idleOffset;
float idleSpeed;

float3 ReactToOtherBoids(uint id)
{
    Boid boid = boids[id];
    float3 pos = boid.position;
    float3 vel = boid.velocity;

    float3 avoidDir = float3(0, 0, 0);
    float3 centre = float3(0, 0, 0);
    float3 velocityMatch = float3(0, 0, 0);

    uint neighbourCount = 0;
    for (uint i = 0; i < numBoids; i++)
    {
        if (i != id)
        {
            Boid otherBoid = boids[i];
            float dist = distance(pos, otherBoid.position);
            //if (dist < avoidDist && dot(normalize(vel), normalize(otherBoid.velocity)) > BOID_VISION_CONE_MIN_DOT)
            if (dist < avoidDist)
            {
                neighbourCount++;
                avoidDir += (pos - otherBoid.position) * saturate(1.0f - (dist / avoidDist)); //scale avoid speed by distance
                centre += otherBoid.position - pos;
                velocityMatch += otherBoid.velocity;
            }
        }
    }

    float avg = 1.0f / (float)(neighbourCount + (int)(neighbourCount == 0)); //if neighbourCount == 0, add 1 to avoid a divide-by-zero
    centre *= avg;
    velocityMatch *= avg;

    return (normalize(avoidDir) * avoidSpeed) + normalize(centre) + velocityMatch;
}

/*
float3 MoveIdle(uint id)
{
    return normalize(Directional3D(boids[id].position, idleNoiseFrequency, idleOffset)) * idleSpeed * (int)usingIdleMvmt;
}
*/

float3 FollowCursor(uint id)
{
    return normalize(cursorPos - boids[id].position) * cursorFollowSpeed * (int)usingCursorFollow;
}

/*
float3 ReturnToBounds()
{
    
}
*/

[numthreads(GROUP_SIZE,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 flocking = ReactToOtherBoids(id.x);
    //float3 followCursor = FollowCursor(id.x);

    boids[id.x] = ConstructBoid(boids[id.x].position, flocking); 
}
